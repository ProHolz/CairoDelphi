unit Cairo.Freetype;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }

{$MINENUMSIZE 4}

interface

const
  LIBFT = 'cairo.dll';
  _PU = '';

const
  FT_FREETYPE_H = 1;
  FT_RENDER_POOL_SIZE = 16384;
  FT_MAX_MODULES = 32;
  TT_CONFIG_OPTION_SUBPIXEL_HINTING = 2;
  TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES = 1000000;
  T1_MAX_DICT_DEPTH = 5;
  T1_MAX_SUBRS_CALLS = 16;
  T1_MAX_CHARSTRINGS_OPERANDS = 256;
  CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 = 500;
  CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 = 400;
  CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 = 1000;
  CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 = 275;
  CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 = 1667;
  CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 = 275;
  CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4 = 2333;
  CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 = 0;
  CHAR_BIT = 8;
  FT_CHAR_BIT = CHAR_BIT;
  USHRT_MAX = $ffff;
  FT_USHORT_MAX = USHRT_MAX;
  INT_MAX = 2147483647;
  FT_INT_MAX = INT_MAX;
  INT_MIN = (-2147483647-1);
  FT_INT_MIN = INT_MIN;
  UINT_MAX = $ffffffff;
  FT_UINT_MAX = UINT_MAX;
  LONG_MIN = (-2147483647-1);
  FT_LONG_MIN = LONG_MIN;
  LONG_MAX = 2147483647;
  FT_LONG_MAX = LONG_MAX;
  ULONG_MAX = $ffffffff;
  FT_ULONG_MAX = ULONG_MAX;


  FT_FILE = 0;
  FT_SIZEOF_INT = (32 div FT_CHAR_BIT);
  FT_SIZEOF_LONG = (32 div FT_CHAR_BIT);

  SHRT_MAX = 32767;
  FT_OUTLINE_CONTOURS_MAX = SHRT_MAX;
  FT_OUTLINE_POINTS_MAX = SHRT_MAX;
  FT_OUTLINE_NONE = $0;
  FT_OUTLINE_OWNER = $1;
  FT_OUTLINE_EVEN_ODD_FILL = $2;
  FT_OUTLINE_REVERSE_FILL = $4;
  FT_OUTLINE_IGNORE_DROPOUTS = $8;
  FT_OUTLINE_SMART_DROPOUTS = $10;
  FT_OUTLINE_INCLUDE_STUBS = $20;
  FT_OUTLINE_HIGH_PRECISION = $100;
  FT_OUTLINE_SINGLE_PASS = $200;

  FT_CURVE_TAG_ON = 1;
  FT_CURVE_TAG_CONIC = 0;
  FT_CURVE_TAG_CUBIC = 2;
  FT_CURVE_TAG_HAS_SCANMODE = 4;
  FT_CURVE_TAG_TOUCH_X = 8;
  FT_CURVE_TAG_TOUCH_Y = 16;
  FT_CURVE_TAG_TOUCH_BOTH = (FT_CURVE_TAG_TOUCH_X or FT_CURVE_TAG_TOUCH_Y);

  FT_RASTER_FLAG_DEFAULT = $0;
  FT_RASTER_FLAG_AA = $1;
  FT_RASTER_FLAG_DIRECT = $2;
  FT_RASTER_FLAG_CLIP = $4;


  FT_ERR_BASE = 0;

  { TODO : Add the Errorcodes from FTError.h }


  FT_FACE_FLAG_SCALABLE = (1 shl 0);
  FT_FACE_FLAG_FIXED_SIZES = (1 shl 1);
  FT_FACE_FLAG_FIXED_WIDTH = (1 shl 2);
  FT_FACE_FLAG_SFNT = (1 shl 3);
  FT_FACE_FLAG_HORIZONTAL = (1 shl 4);
  FT_FACE_FLAG_VERTICAL = (1 shl 5);
  FT_FACE_FLAG_KERNING = (1 shl 6);
  FT_FACE_FLAG_FAST_GLYPHS = (1 shl 7);
  FT_FACE_FLAG_MULTIPLE_MASTERS = (1 shl 8);
  FT_FACE_FLAG_GLYPH_NAMES = (1 shl 9);
  FT_FACE_FLAG_EXTERNAL_STREAM = (1 shl 10);
  FT_FACE_FLAG_HINTER = (1 shl 11);
  FT_FACE_FLAG_CID_KEYED = (1 shl 12);
  FT_FACE_FLAG_TRICKY = (1 shl 13);
  FT_FACE_FLAG_COLOR = (1 shl 14);
  FT_FACE_FLAG_VARIATION = (1 shl 15);


  FT_STYLE_FLAG_ITALIC = (1 shl 0);
  FT_STYLE_FLAG_BOLD = (1 shl 1);
  FT_OPEN_MEMORY = $1;
  FT_OPEN_STREAM = $2;
  FT_OPEN_PATHNAME = $4;
  FT_OPEN_DRIVER = $8;
  FT_OPEN_PARAMS = $10;

  (* ft_open_params FT_OPEN_PARAMS *)
  FT_LOAD_DEFAULT = $0;
  FT_LOAD_NO_SCALE = (1 shl 0);
  FT_LOAD_NO_HINTING = (1 shl 1);
  FT_LOAD_RENDER = (1 shl 2);
  FT_LOAD_NO_BITMAP = (1 shl 3);
  FT_LOAD_VERTICAL_LAYOUT = (1 shl 4);
  FT_LOAD_FORCE_AUTOHINT = (1 shl 5);
  FT_LOAD_CROP_BITMAP = (1 shl 6);
  FT_LOAD_PEDANTIC = (1 shl 7);
  FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH = (1 shl 9);
  FT_LOAD_NO_RECURSE = (1 shl 10);
  FT_LOAD_IGNORE_TRANSFORM = (1 shl 11);
  FT_LOAD_MONOCHROME = (1 shl 12);
  FT_LOAD_LINEAR_DESIGN = (1 shl 13);
  FT_LOAD_NO_AUTOHINT = (1 shl 15);
  FT_LOAD_COLOR = (1 shl 20);
  FT_LOAD_COMPUTE_METRICS = (1 shl 21);
  FT_LOAD_BITMAP_METRICS_ONLY = (1 shl 22);
  FT_LOAD_ADVANCE_ONLY = (1 shl 8);
  FT_LOAD_SBITS_ONLY = (1 shl 14);

  FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS = 1;
  FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES = 2;
  FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID = 4;
  FT_SUBGLYPH_FLAG_SCALE = 8;
  FT_SUBGLYPH_FLAG_XY_SCALE = $40;
  FT_SUBGLYPH_FLAG_2X2 = $80;
  FT_SUBGLYPH_FLAG_USE_MY_METRICS = $200;
  FT_FSTYPE_INSTALLABLE_EMBEDDING = $0000;
  FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING = $0002;
  FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING = $0004;
  FT_FSTYPE_EDITABLE_EMBEDDING = $0008;
  FT_FSTYPE_NO_SUBSETTING = $0100;
  FT_FSTYPE_BITMAP_EMBEDDING_ONLY = $0200;
  FREETYPE_MAJOR = 2;
  FREETYPE_MINOR = 9;
  FREETYPE_PATCH = 1;

type
  // Forward declarations
  PFT_RasterRec_ = Pointer;
  PPFT_RasterRec_ = ^PFT_RasterRec_;
  PFT_LibraryRec_ = Pointer;
  PPFT_LibraryRec_ = ^PFT_LibraryRec_;
  PFT_ModuleRec_ = Pointer;
  PPFT_ModuleRec_ = ^PFT_ModuleRec_;
  PFT_DriverRec_ = Pointer;
  PPFT_DriverRec_ = ^PFT_DriverRec_;
  PFT_RendererRec_ = Pointer;
  PPFT_RendererRec_ = ^PFT_RendererRec_;
  PFT_Face_InternalRec_ = Pointer;
  PPFT_Face_InternalRec_ = ^PFT_Face_InternalRec_;
  PFT_Size_InternalRec_ = Pointer;
  PPFT_Size_InternalRec_ = ^PFT_Size_InternalRec_;
  PFT_SubGlyphRec_ = Pointer;
  PPFT_SubGlyphRec_ = ^PFT_SubGlyphRec_;
  PFT_Slot_InternalRec_ = Pointer;
  PPFT_Slot_InternalRec_ = ^PFT_Slot_InternalRec_;
  PFT_MemoryRec_ = ^FT_MemoryRec_;
  PFT_StreamRec_ = ^FT_StreamRec_;
  PFT_Vector_ = ^FT_Vector_;
  PFT_BBox_ = ^FT_BBox_;
  PFT_Bitmap_ = ^FT_Bitmap_;
  PFT_Outline_ = ^FT_Outline_;
  PFT_Outline_Funcs_ = ^FT_Outline_Funcs_;
  PFT_Span_ = ^FT_Span_;
  PFT_Raster_Params_ = ^FT_Raster_Params_;
  PFT_Raster_Funcs_ = ^FT_Raster_Funcs_;
  PFT_UnitVector_ = ^FT_UnitVector_;
  PFT_Matrix_ = ^FT_Matrix_;
  PFT_Data_ = ^FT_Data_;
  PFT_Generic_ = ^FT_Generic_;
  PFT_ListNodeRec_ = ^FT_ListNodeRec_;
  PFT_ListRec_ = ^FT_ListRec_;
  PFT_Glyph_Metrics_ = ^FT_Glyph_Metrics_;
  PFT_Bitmap_Size_ = ^FT_Bitmap_Size_;
  PFT_CharMapRec_ = ^FT_CharMapRec_;
  PFT_FaceRec_ = ^FT_FaceRec_;
  PFT_Size_Metrics_ = ^FT_Size_Metrics_;
  PFT_SizeRec_ = ^FT_SizeRec_;
  PFT_GlyphSlotRec_ = ^FT_GlyphSlotRec_;
  PFT_Parameter_ = ^FT_Parameter_;
  PFT_Open_Args_ = ^FT_Open_Args_;
  PFT_Size_RequestRec_ = ^FT_Size_RequestRec_;

  (*************************************************************************)
  FT_Int16 = Smallint;
  (*************************************************************************)
  FT_UInt16 = Word;
  FT_Int32 = Integer;
  FT_UInt32 = Cardinal;
  PFT_UInt32 = ^FT_UInt32;
  FT_Fast = Integer;
  FT_UFast = Cardinal;
  FT_Int64 = Int64;
  FT_UInt64 = UInt64;
   UTF8Char = AnsiChar;
  PUTF8Char = PAnsiChar;
  (*************************************************************************
   *
   * @type:
   *   FT_Memory
   *
   * @description:
   *   A handle to a given memory manager object, defined with an
   *   @FT_MemoryRec structure.
   *
   *)
  FT_Memory = PFT_MemoryRec_;

  (*************************************************************************
   *
   * @functype:
   *   FT_Alloc_Func
   *
   * @description:
   *   A function used to allocate `size' bytes from `memory'.
   *
   * @input:
   *   memory ::
   *     A handle to the source memory manager.
   *
   *   size ::
   *     The size in bytes to allocate.
   *
   * @return:
   *   Address of new memory block.  0~in case of failure.
   *
   *)
  FT_Alloc_Func = function(memory: FT_Memory; size: Integer): Pointer; cdecl;

  (*************************************************************************
   *
   * @functype:
   *   FT_Free_Func
   *
   * @description:
   *   A function used to release a given block of memory.
   *
   * @input:
   *   memory ::
   *     A handle to the source memory manager.
   *
   *   block ::
   *     The address of the target memory block.
   *
   *)
  FT_Free_Func = procedure(memory: FT_Memory; block: Pointer); cdecl;

  (*************************************************************************
   *
   * @functype:
   *   FT_Realloc_Func
   *
   * @description:
   *   A function used to re-allocate a given block of memory.
   *
   * @input:
   *   memory ::
   *     A handle to the source memory manager.
   *
   *   cur_size ::
   *     The block's current size in bytes.
   *
   *   new_size ::
   *     The block's requested new size.
   *
   *   block ::
   *     The block's current address.
   *
   * @return:
   *   New block address.  0~in case of memory shortage.
   *
   * @note:
   *   In case of error, the old block must still be available.
   *
   *)
  FT_Realloc_Func = function(memory: FT_Memory; cur_size: Integer; new_size: Integer; block: Pointer): Pointer; cdecl;

  (*************************************************************************
   *
   * @struct:
   *   FT_MemoryRec
   *
   * @description:
   *   A structure used to describe a given memory manager to FreeType~2.
   *
   * @fields:
   *   user ::
   *     A generic typeless pointer for user data.
   *
   *   alloc ::
   *     A pointer type to an allocation function.
   *
   *   free ::
   *     A pointer type to an memory freeing function.
   *
   *   realloc ::
   *     A pointer type to a reallocation function.
   *
   *)
  FT_MemoryRec_ = record
    user: Pointer;
    alloc: FT_Alloc_Func;
    free: FT_Free_Func;
    realloc: FT_Realloc_Func;
  end;

  (*************************************************************************
   *
   * @type:
   *   FT_Stream
   *
   * @description:
   *   A handle to an input stream.
   *
   * @also:
   *   See @FT_StreamRec for the publicly accessible fields of a given
   *   stream object.
   *
   *)
  FT_Stream = PFT_StreamRec_;

  (*************************************************************************
   *
   * @struct:
   *   FT_StreamDesc
   *
   * @description:
   *   A union type used to store either a long or a pointer.  This is used
   *   to store a file descriptor or a `FILE*' in an input stream.
   *
   *)
  FT_StreamDesc_ = record
    case Integer of
      0: (value: Integer);
      1: (pointer: Pointer);
  end;

  FT_StreamDesc = FT_StreamDesc_;

  (*************************************************************************
   *
   * @functype:
   *   FT_Stream_IoFunc
   *
   * @description:
   *   A function used to seek and read data from a given input stream.
   *
   * @input:
   *   stream ::
   *     A handle to the source stream.
   *
   *   offset ::
   *     The offset of read in stream (always from start).
   *
   *   buffer ::
   *     The address of the read buffer.
   *
   *   count ::
   *     The number of bytes to read from the stream.
   *
   * @return:
   *   The number of bytes effectively read by the stream.
   *
   * @note:
   *   This function might be called to perform a seek or skip operation
   *   with a `count' of~0.  A non-zero return value then indicates an
   *   error.
   *
   *)
  FT_Stream_IoFunc = function(stream: FT_Stream; offset: Cardinal; buffer: PByte; count: Cardinal): Cardinal; cdecl;

  (*************************************************************************
   *
   * @functype:
   *   FT_Stream_CloseFunc
   *
   * @description:
   *   A function used to close a given input stream.
   *
   * @input:
   *  stream ::
   *     A handle to the target stream.
   *
   *)
  FT_Stream_CloseFunc = procedure(stream: FT_Stream); cdecl;

  (*************************************************************************
   *
   * @struct:
   *   FT_StreamRec
   *
   * @description:
   *   A structure used to describe an input stream.
   *
   * @input:
   *   base ::
   *     For memory-based streams, this is the address of the first stream
   *     byte in memory.  This field should always be set to NULL for
   *     disk-based streams.
   *
   *   size ::
   *     The stream size in bytes.
   *
   *     In case of compressed streams where the size is unknown before
   *     actually doing the decompression, the value is set to 0x7FFFFFFF.
   *     (Note that this size value can occur for normal streams also; it is
   *     thus just a hint.)
   *
   *   pos ::
   *     The current position within the stream.
   *
   *   descriptor ::
   *     This field is a union that can hold an integer or a pointer.  It is
   *     used by stream implementations to store file descriptors or `FILE*'
   *     pointers.
   *
   *   pathname ::
   *     This field is completely ignored by FreeType.  However, it is often
   *     useful during debugging to use it to store the stream's filename
   *     (where available).
   *
   *   read ::
   *     The stream's input function.
   *
   *   close ::
   *     The stream's close function.
   *
   *   memory ::
   *     The memory manager to use to preload frames.  This is set
   *     internally by FreeType and shouldn't be touched by stream
   *     implementations.
   *
   *   cursor ::
   *     This field is set and used internally by FreeType when parsing
   *     frames.
   *
   *   limit ::
   *     This field is set and used internally by FreeType when parsing
   *     frames.
   *
   *)
  FT_StreamRec_ = record
    base: PByte;
    size: Cardinal;
    pos: Cardinal;
    descriptor: FT_StreamDesc;
    pathname: FT_StreamDesc;
    read: FT_Stream_IoFunc;
    close: FT_Stream_CloseFunc;
    memory: FT_Memory;
    cursor: PByte;
    limit: PByte;
  end;

  FT_StreamRec = FT_StreamRec_;
  (*************************************************************************)
  FT_Pos = Integer;

  FT_Vector_ = record
    x: FT_Pos;
    y: FT_Pos;
  end;

  FT_Vector = FT_Vector_;
  PFT_Vector = ^FT_Vector;

  (*************************************************************************)
  FT_BBox_ = record
    xMin: FT_Pos;
    yMin: FT_Pos;
    xMax: FT_Pos;
    yMax: FT_Pos;
  end;

  FT_BBox = FT_BBox_;

  FT_Pixel_Mode_ = (
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO = 1,
    FT_PIXEL_MODE_GRAY = 2,
    FT_PIXEL_MODE_GRAY2 = 3,
    FT_PIXEL_MODE_GRAY4 = 4,
    FT_PIXEL_MODE_LCD = 5,
    FT_PIXEL_MODE_LCD_V = 6,
    FT_PIXEL_MODE_BGRA = 7,
    FT_PIXEL_MODE_MAX = 8);
  PFT_Pixel_Mode_ = ^FT_Pixel_Mode_;
  FT_Pixel_Mode = FT_Pixel_Mode_;

  FT_Bitmap_ = record
    rows: Cardinal;
    width: Cardinal;
    pitch: Integer;
    buffer: PByte;
    num_grays: Word;
    pixel_mode: Byte;
    palette_mode: Byte;
    palette: Pointer;
  end;

  FT_Bitmap = FT_Bitmap_;
  PFT_Bitmap = ^FT_Bitmap;

  FT_Outline_ = record
    n_contours: Smallint;
    n_points: Smallint;
    points: PFT_Vector;
    tags: PUTF8Char;
    contours: PSmallint;
    flags: Integer;
  end;

  FT_Outline = FT_Outline_;

  (*************************************************************************)
  FT_Outline_MoveToFunc = function(&to: PFT_Vector; user: Pointer): Integer; cdecl;

  (*************************************************************************)
  FT_Outline_LineToFunc = function(&to: PFT_Vector; user: Pointer): Integer; cdecl;

  (*************************************************************************)
  FT_Outline_ConicToFunc = function(control: PFT_Vector; &to: PFT_Vector; user: Pointer): Integer; cdecl;

  (*************************************************************************)
  FT_Outline_CubicToFunc = function(control1: PFT_Vector; control2: PFT_Vector; &to: PFT_Vector; user: Pointer): Integer; cdecl;

  FT_Outline_Funcs_ = record
    move_to: FT_Outline_MoveToFunc;
    line_to: FT_Outline_LineToFunc;
    conic_to: FT_Outline_ConicToFunc;
    cubic_to: FT_Outline_CubicToFunc;
    shift: Integer;
    delta: FT_Pos;
  end;

  FT_Outline_Funcs = FT_Outline_Funcs_;

  FT_Glyph_Format_ = (
    FT_GLYPH_FORMAT_NONE = 0,
    FT_GLYPH_FORMAT_COMPOSITE = 1668246896,
    FT_GLYPH_FORMAT_BITMAP = 1651078259,
    FT_GLYPH_FORMAT_OUTLINE = 1869968492,
    FT_GLYPH_FORMAT_PLOTTER = 1886154612);
  PFT_Glyph_Format_ = ^FT_Glyph_Format_;
  FT_Glyph_Format = FT_Glyph_Format_;
  FT_Raster = Pointer;
  PFT_Raster = ^FT_Raster;

  FT_Span_ = record
    x: Smallint;
    len: Word;
    coverage: Byte;
  end;

  FT_Span = FT_Span_;
  PFT_Span = ^FT_Span;

  (*************************************************************************)
  FT_SpanFunc = procedure(y: Integer; count: Integer; spans: PFT_Span; user: Pointer); cdecl;

  (*************************************************************************)
  FT_Raster_BitTest_Func = function(y: Integer; x: Integer; user: Pointer): Integer; cdecl;

  (*************************************************************************)
  FT_Raster_BitSet_Func = procedure(y: Integer; x: Integer; user: Pointer); cdecl;

  FT_Raster_Params_ = record
    target: PFT_Bitmap;
    source: Pointer;
    flags: Integer;
    gray_spans: FT_SpanFunc;
    black_spans: FT_SpanFunc;
    bit_test: FT_Raster_BitTest_Func;
    bit_set: FT_Raster_BitSet_Func;
    user: Pointer;
    clip_box: FT_BBox;
  end;

  FT_Raster_Params = FT_Raster_Params_;
  PFT_Raster_Params = ^FT_Raster_Params;

  FT_Raster_NewFunc = function(memory: Pointer; raster: PFT_Raster): Integer; cdecl;

  (*************************************************************************)
  FT_Raster_DoneFunc = procedure(raster: FT_Raster); cdecl;

  (*************************************************************************)
  FT_Raster_ResetFunc = procedure(raster: FT_Raster; pool_base: PByte; pool_size: Cardinal); cdecl;

  (*************************************************************************)
  FT_Raster_SetModeFunc = function(raster: FT_Raster; mode: Cardinal; args: Pointer): Integer; cdecl;

  FT_Raster_RenderFunc = function(raster: FT_Raster; params: PFT_Raster_Params): Integer; cdecl;

  (*************************************************************************)
  FT_Raster_Funcs_ = record
    glyph_format: FT_Glyph_Format;
    raster_new: FT_Raster_NewFunc;
    raster_reset: FT_Raster_ResetFunc;
    raster_set_mode: FT_Raster_SetModeFunc;
    raster_render: FT_Raster_RenderFunc;
    raster_done: FT_Raster_DoneFunc;
  end;

  FT_Raster_Funcs = FT_Raster_Funcs_;
  (*************************************************************************)
  FT_Bool = Byte;
  (*************************************************************************)
  FT_FWord = Smallint;
  (*************************************************************************)
  FT_UFWord = Word;
  (*************************************************************************)
  FT_Char = Shortint;
  (*************************************************************************)
  FT_Byte = Byte;
  PFT_Byte = ^FT_Byte;
  (*************************************************************************)
  FT_Bytes = PFT_Byte;
  (*************************************************************************)
  FT_Tag = FT_UInt32;
  (*************************************************************************)
  FT_String = UTF8Char;
  PFT_String = PUTF8Char;
  (*************************************************************************)
  FT_Short = Smallint;
  (*************************************************************************)
  FT_UShort = Word;
  (*************************************************************************)
  FT_Int = Integer;
  PFT_Int = ^FT_Int;
  (*************************************************************************)
  FT_UInt = Cardinal;
  PFT_UInt = ^FT_UInt;
  (*************************************************************************)
  FT_Long = Integer;
  (*************************************************************************)
  FT_ULong = Cardinal;
  (*************************************************************************)
  FT_F2Dot14 = Smallint;
  (*************************************************************************)
  FT_F26Dot6 = Integer;
  (*************************************************************************)
  FT_Fixed = Integer;
  PFT_Fixed = ^FT_Fixed;
  (*************************************************************************)
  FT_Error = Integer;
  (*************************************************************************)
  FT_Pointer = Pointer;
  (*************************************************************************)
  FT_Offset = NativeUInt;
  (*************************************************************************)
  FT_PtrDist = NativeInt;

  (*************************************************************************)
  FT_UnitVector_ = record
    x: FT_F2Dot14;
    y: FT_F2Dot14;
  end;

  FT_UnitVector = FT_UnitVector_;

  FT_Matrix_ = record
    xx: FT_Fixed;
    xy: FT_Fixed;
    yx: FT_Fixed;
    yy: FT_Fixed;
  end;

  FT_Matrix = FT_Matrix_;
  PFT_Matrix = ^FT_Matrix;

  (*************************************************************************)
  FT_Data_ = record
    pointer: PFT_Byte;
    length: FT_Int;
  end;

  FT_Data = FT_Data_;

  FT_Generic_Finalizer = procedure(&object: Pointer); cdecl;

  (*************************************************************************)
  FT_Generic_ = record
    data: Pointer;
    finalizer: FT_Generic_Finalizer;
  end;

  FT_Generic = FT_Generic_;
  FT_ListNode = PFT_ListNodeRec_;
  FT_List = PFT_ListRec_;

  (*************************************************************************)
  FT_ListNodeRec_ = record
    prev: FT_ListNode;
    next: FT_ListNode;
    data: Pointer;
  end;

  FT_ListNodeRec = FT_ListNodeRec_;

  (*************************************************************************)
  FT_ListRec_ = record
    head: FT_ListNode;
    tail: FT_ListNode;
  end;

  FT_ListRec = FT_ListRec_;

  _anonymous_type_1 = (
    FT_Mod_Err_Base = 0,
    FT_Mod_Err_Autofit = 0,
    FT_Mod_Err_BDF = 0,
    FT_Mod_Err_Bzip2 = 0,
    FT_Mod_Err_Cache = 0,
    FT_Mod_Err_CFF = 0,
    FT_Mod_Err_CID = 0,
    FT_Mod_Err_Gzip = 0,
    FT_Mod_Err_LZW = 0,
    FT_Mod_Err_OTvalid = 0,
    FT_Mod_Err_PCF = 0,
    FT_Mod_Err_PFR = 0,
    FT_Mod_Err_PSaux = 0,
    FT_Mod_Err_PShinter = 0,
    FT_Mod_Err_PSnames = 0,
    FT_Mod_Err_Raster = 0,
    FT_Mod_Err_SFNT = 0,
    FT_Mod_Err_Smooth = 0,
    FT_Mod_Err_TrueType = 0,
    FT_Mod_Err_Type1 = 0,
    FT_Mod_Err_Type42 = 0,
    FT_Mod_Err_Winfonts = 0,
    FT_Mod_Err_GXvalid = 0,
    FT_Mod_Err_Max = 1);
  P_anonymous_type_1 = ^_anonymous_type_1;

  _ftErrorEnum = (
    FT_Err_Ok = 0,
    FT_Err_Cannot_Open_Resource = 1,
    FT_Err_Unknown_File_Format = 2,
    FT_Err_Invalid_File_Format = 3,
    FT_Err_Invalid_Version = 4,
    FT_Err_Lower_Module_Version = 5,
    FT_Err_Invalid_Argument = 6,
    FT_Err_Unimplemented_Feature = 7,
    FT_Err_Invalid_Table = 8,
    FT_Err_Invalid_Offset = 9,
    FT_Err_Array_Too_Large = 10,
    FT_Err_Missing_Module = 11,
    FT_Err_Missing_Property = 12,
    FT_Err_Invalid_Glyph_Index = 16,
    FT_Err_Invalid_Character_Code = 17,
    FT_Err_Invalid_Glyph_Format = 18,
    FT_Err_Cannot_Render_Glyph = 19,
    FT_Err_Invalid_Outline = 20,
    FT_Err_Invalid_Composite = 21,
    FT_Err_Too_Many_Hints = 22,
    FT_Err_Invalid_Pixel_Size = 23,
    FT_Err_Invalid_Handle = 32,
    FT_Err_Invalid_Library_Handle = 33,
    FT_Err_Invalid_Driver_Handle = 34,
    FT_Err_Invalid_Face_Handle = 35,
    FT_Err_Invalid_Size_Handle = 36,
    FT_Err_Invalid_Slot_Handle = 37,
    FT_Err_Invalid_CharMap_Handle = 38,
    FT_Err_Invalid_Cache_Handle = 39,
    FT_Err_Invalid_Stream_Handle = 40,
    FT_Err_Too_Many_Drivers = 48,
    FT_Err_Too_Many_Extensions = 49,
    FT_Err_Out_Of_Memory = 64,
    FT_Err_Unlisted_Object = 65,
    FT_Err_Cannot_Open_Stream = 81,
    FT_Err_Invalid_Stream_Seek = 82,
    FT_Err_Invalid_Stream_Skip = 83,
    FT_Err_Invalid_Stream_Read = 84,
    FT_Err_Invalid_Stream_Operation = 85,
    FT_Err_Invalid_Frame_Operation = 86,
    FT_Err_Nested_Frame_Access = 87,
    FT_Err_Invalid_Frame_Read = 88,
    FT_Err_Raster_Uninitialized = 96,
    FT_Err_Raster_Corrupted = 97,
    FT_Err_Raster_Overflow = 98,
    FT_Err_Raster_Negative_Height = 99,
    FT_Err_Too_Many_Caches = 112,
    FT_Err_Invalid_Opcode = 128,
    FT_Err_Too_Few_Arguments = 129,
    FT_Err_Stack_Overflow = 130,
    FT_Err_Code_Overflow = 131,
    FT_Err_Bad_Argument = 132,
    FT_Err_Divide_By_Zero = 133,
    FT_Err_Invalid_Reference = 134,
    FT_Err_Debug_OpCode = 135,
    FT_Err_ENDF_In_Exec_Stream = 136,
    FT_Err_Nested_DEFS = 137,
    FT_Err_Invalid_CodeRange = 138,
    FT_Err_Execution_Too_Long = 139,
    FT_Err_Too_Many_Function_Defs = 140,
    FT_Err_Too_Many_Instruction_Defs = 141,
    FT_Err_Table_Missing = 142,
    FT_Err_Horiz_Header_Missing = 143,
    FT_Err_Locations_Missing = 144,
    FT_Err_Name_Table_Missing = 145,
    FT_Err_CMap_Table_Missing = 146,
    FT_Err_Hmtx_Table_Missing = 147,
    FT_Err_Post_Table_Missing = 148,
    FT_Err_Invalid_Horiz_Metrics = 149,
    FT_Err_Invalid_CharMap_Format = 150,
    FT_Err_Invalid_PPem = 151,
    FT_Err_Invalid_Vert_Metrics = 152,
    FT_Err_Could_Not_Find_Context = 153,
    FT_Err_Invalid_Post_Table_Format = 154,
    FT_Err_Invalid_Post_Table = 155,
    FT_Err_DEF_In_Glyf_Bytecode = 156,
    FT_Err_Missing_Bitmap = 157,
    FT_Err_Syntax_Error = 160,
    FT_Err_Stack_Underflow = 161,
    FT_Err_Ignore = 162,
    FT_Err_No_Unicode_Glyph_Name = 163,
    FT_Err_Glyph_Too_Big = 164,
    FT_Err_Missing_Startfont_Field = 176,
    FT_Err_Missing_Font_Field = 177,
    FT_Err_Missing_Size_Field = 178,
    FT_Err_Missing_Fontboundingbox_Field = 179,
    FT_Err_Missing_Chars_Field = 180,
    FT_Err_Missing_Startchar_Field = 181,
    FT_Err_Missing_Encoding_Field = 182,
    FT_Err_Missing_Bbx_Field = 183,
    FT_Err_Bbx_Too_Big = 184,
    FT_Err_Corrupted_Font_Header = 185,
    FT_Err_Corrupted_Font_Glyphs = 186,
    FT_Err_Max = 187);


  FT_Glyph_Metrics_ = record
    width: FT_Pos;
    height: FT_Pos;
    horiBearingX: FT_Pos;
    horiBearingY: FT_Pos;
    horiAdvance: FT_Pos;
    vertBearingX: FT_Pos;
    vertBearingY: FT_Pos;
    vertAdvance: FT_Pos;
  end;

  FT_Glyph_Metrics = FT_Glyph_Metrics_;

  FT_Bitmap_Size_ = record
    height: FT_Short;
    width: FT_Short;
    size: FT_Pos;
    x_ppem: FT_Pos;
    y_ppem: FT_Pos;
  end;

  FT_Bitmap_Size = FT_Bitmap_Size_;
  PFT_Bitmap_Size = ^FT_Bitmap_Size;
  FT_Library = NativeInt; //Pointer;
  PFT_Library = ^FT_Library;
  FT_Module = Pointer;
  PFT_Module = ^FT_Module;
  FT_Driver = Pointer;
  PFT_Driver = ^FT_Driver;
  FT_Renderer = Pointer;
  PFT_Renderer = ^FT_Renderer;
  FT_Face = PFT_FaceRec_;
  PFT_Face = ^FT_Face;
  FT_Size = PFT_SizeRec_;
  FT_GlyphSlot = PFT_GlyphSlotRec_;
  FT_CharMap = PFT_CharMapRec_;
  PFT_CharMap = ^FT_CharMap;

  FT_Encoding_ = (
    FT_ENCODING_NONE = 0,
    FT_ENCODING_MS_SYMBOL = 1937337698,
    FT_ENCODING_UNICODE = 1970170211,
    FT_ENCODING_SJIS = 1936353651,
    FT_ENCODING_PRC = 1734484000,
    FT_ENCODING_BIG5 = 1651074869,
    FT_ENCODING_WANSUNG = 2002873971,
    FT_ENCODING_JOHAB = 1785686113,
    FT_ENCODING_GB2312 = 1734484000,
    FT_ENCODING_MS_SJIS = 1936353651,
    FT_ENCODING_MS_GB2312 = 1734484000,
    FT_ENCODING_MS_BIG5 = 1651074869,
    FT_ENCODING_MS_WANSUNG = 2002873971,
    FT_ENCODING_MS_JOHAB = 1785686113,
    FT_ENCODING_ADOBE_STANDARD = 1094995778,
    FT_ENCODING_ADOBE_EXPERT = 1094992453,
    FT_ENCODING_ADOBE_CUSTOM = 1094992451,
    FT_ENCODING_ADOBE_LATIN_1 = 1818326065,
    FT_ENCODING_OLD_LATIN_2 = 1818326066,
    FT_ENCODING_APPLE_ROMAN = 1634889070);
  PFT_Encoding_ = ^FT_Encoding_;
  FT_Encoding = FT_Encoding_;

  FT_CharMapRec_ = record
    face: FT_Face;
    encoding: FT_Encoding;
    platform_id: FT_UShort;
    encoding_id: FT_UShort;
  end;

  FT_CharMapRec = FT_CharMapRec_;
  FT_Face_Internal = Pointer;
  PFT_Face_Internal = ^FT_Face_Internal;

  FT_FaceRec_ = record
    num_faces: FT_Long;
    face_index: FT_Long;
    face_flags: FT_Long;
    style_flags: FT_Long;
    num_glyphs: FT_Long;
    family_name: PFT_String;
    style_name: PFT_String;
    num_fixed_sizes: FT_Int;
    available_sizes: PFT_Bitmap_Size;
    num_charmaps: FT_Int;
    charmaps: PFT_CharMap;
    generic: FT_Generic;
    bbox: FT_BBox;
    units_per_EM: FT_UShort;
    ascender: FT_Short;
    descender: FT_Short;
    height: FT_Short;
    max_advance_width: FT_Short;
    max_advance_height: FT_Short;
    underline_position: FT_Short;
    underline_thickness: FT_Short;
    glyph: FT_GlyphSlot;
    size: FT_Size;
    charmap: FT_CharMap;
    driver: FT_Driver;
    memory: FT_Memory;
    stream: FT_Stream;
    sizes_list: FT_ListRec;
    autohint: FT_Generic;
    extensions: Pointer;
    internal: FT_Face_Internal;
  end;

  FT_FaceRec = FT_FaceRec_;
  FT_Size_Internal = Pointer;
  PFT_Size_Internal = ^FT_Size_Internal;

  FT_Size_Metrics_ = record
    x_ppem: FT_UShort;
    y_ppem: FT_UShort;
    x_scale: FT_Fixed;
    y_scale: FT_Fixed;
    ascender: FT_Pos;
    descender: FT_Pos;
    height: FT_Pos;
    max_advance: FT_Pos;
  end;

  FT_Size_Metrics = FT_Size_Metrics_;

  (*************************************************************************)
  FT_SizeRec_ = record
    face: FT_Face;
    generic: FT_Generic;
    metrics: FT_Size_Metrics;
    internal: FT_Size_Internal;
  end;

  FT_SizeRec = FT_SizeRec_;
  FT_SubGlyph = Pointer;
  PFT_SubGlyph = ^FT_SubGlyph;
  FT_Slot_Internal = Pointer;
  PFT_Slot_Internal = ^FT_Slot_Internal;

  FT_GlyphSlotRec_ = record
    &library: FT_Library;
    face: FT_Face;
    next: FT_GlyphSlot;
    reserved: FT_UInt;
    generic: FT_Generic;
    metrics: FT_Glyph_Metrics;
    linearHoriAdvance: FT_Fixed;
    linearVertAdvance: FT_Fixed;
    advance: FT_Vector;
    format: FT_Glyph_Format;
    bitmap: FT_Bitmap;
    bitmap_left: FT_Int;
    bitmap_top: FT_Int;
    outline: FT_Outline;
    num_subglyphs: FT_UInt;
    subglyphs: FT_SubGlyph;
    control_data: Pointer;
    control_len: Integer;
    lsb_delta: FT_Pos;
    rsb_delta: FT_Pos;
    other: Pointer;
    internal: FT_Slot_Internal;
  end;

  FT_GlyphSlotRec = FT_GlyphSlotRec_;

  FT_Parameter_ = record
    tag: FT_ULong;
    data: FT_Pointer;
  end;

  FT_Parameter = FT_Parameter_;
  PFT_Parameter = ^FT_Parameter;

  FT_Open_Args_ = record
    flags: FT_UInt;
    memory_base: PFT_Byte;
    memory_size: FT_Long;
    pathname: PFT_String;
    stream: FT_Stream;
    driver: FT_Module;
    num_params: FT_Int;
    params: PFT_Parameter;
  end;

  FT_Open_Args = FT_Open_Args_;
  PFT_Open_Args = ^FT_Open_Args;

  FT_Size_Request_Type_ = (
    FT_SIZE_REQUEST_TYPE_NOMINAL = 0,
    FT_SIZE_REQUEST_TYPE_REAL_DIM = 1,
    FT_SIZE_REQUEST_TYPE_BBOX = 2,
    FT_SIZE_REQUEST_TYPE_CELL = 3,
    FT_SIZE_REQUEST_TYPE_SCALES = 4,
    FT_SIZE_REQUEST_TYPE_MAX = 5);
  PFT_Size_Request_Type_ = ^FT_Size_Request_Type_;
  FT_Size_Request_Type = FT_Size_Request_Type_;

  FT_Size_RequestRec_ = record
    &type: FT_Size_Request_Type;
    width: FT_Long;
    height: FT_Long;
    horiResolution: FT_UInt;
    vertResolution: FT_UInt;
  end;

  FT_Size_RequestRec = FT_Size_RequestRec_;
  (*************************************************************************)
  FT_Size_Request = PFT_Size_RequestRec_;

  FT_Render_Mode_ = (
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT = 1,
    FT_RENDER_MODE_MONO = 2,
    FT_RENDER_MODE_LCD = 3,
    FT_RENDER_MODE_LCD_V = 4,
    FT_RENDER_MODE_MAX = 5);
  PFT_Render_Mode_ = ^FT_Render_Mode_;
  FT_Render_Mode = FT_Render_Mode_;

  FT_Kerning_Mode_ = (
    FT_KERNING_DEFAULT = 0,
    FT_KERNING_UNFITTED = 1,
    FT_KERNING_UNSCALED = 2);
  PFT_Kerning_Mode_ = ^FT_Kerning_Mode_;
  FT_Kerning_Mode = FT_Kerning_Mode_;

function FT_Init_FreeType(var alibrary: FT_Library): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Init_FreeType';

(*************************************************************************)
function FT_Done_FreeType(&library: FT_Library): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Done_FreeType';

function FT_New_Face(&library: FT_Library; filepathname: PUTF8Char; face_index: FT_Long; var aface: FT_Face): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_New_Face';

function FT_New_Memory_Face(&library: FT_Library; file_base: PFT_Byte; file_size: FT_Long; face_index: FT_Long; aface: PFT_Face): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_New_Memory_Face';

function FT_Open_Face(&library: FT_Library; args: PFT_Open_Args; face_index: FT_Long; aface: PFT_Face): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Open_Face';

function FT_Attach_File(face: FT_Face; filepathname: PUTF8Char): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Attach_File';

function FT_Attach_Stream(face: FT_Face; parameters: PFT_Open_Args): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Attach_Stream';

function FT_Reference_Face(face: FT_Face): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Reference_Face';

function FT_Done_Face(face: FT_Face): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Done_Face';

function FT_Select_Size(face: FT_Face; strike_index: FT_Int): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Select_Size';

function FT_Request_Size(face: FT_Face; req: FT_Size_Request): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Request_Size';

function FT_Set_Char_Size(face: FT_Face; char_width: FT_F26Dot6; char_height: FT_F26Dot6; horz_resolution: FT_UInt; vert_resolution: FT_UInt): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Set_Char_Size';

function FT_Set_Pixel_Sizes(face: FT_Face; pixel_width: FT_UInt; pixel_height: FT_UInt): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Set_Pixel_Sizes';

function FT_Load_Glyph(face: FT_Face; glyph_index: FT_UInt; load_flags: FT_Int32): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Load_Glyph';

function FT_Load_Char(face: FT_Face; char_code: FT_ULong; load_flags: FT_Int32): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Load_Char';

procedure FT_Set_Transform(face: FT_Face; matrix: PFT_Matrix; delta: PFT_Vector); cdecl;
  external LIBFT name _PU + 'FT_Set_Transform';

function FT_Render_Glyph(slot: FT_GlyphSlot; render_mode: FT_Render_Mode): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Render_Glyph';

function FT_Get_Kerning(face: FT_Face; left_glyph: FT_UInt; right_glyph: FT_UInt; kern_mode: FT_UInt; akerning: PFT_Vector): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Get_Kerning';

function FT_Get_Track_Kerning(face: FT_Face; point_size: FT_Fixed; degree: FT_Int; akerning: PFT_Fixed): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Get_Track_Kerning';

function FT_Get_Glyph_Name(face: FT_Face; glyph_index: FT_UInt; buffer: FT_Pointer; buffer_max: FT_UInt): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Get_Glyph_Name';

function FT_Get_Postscript_Name(face: FT_Face): PUTF8Char; cdecl;
  external LIBFT name _PU + 'FT_Get_Postscript_Name';

function FT_Select_Charmap(face: FT_Face; encoding: FT_Encoding): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Select_Charmap';

(*************************************************************************)
function FT_Set_Charmap(face: FT_Face; charmap: FT_CharMap): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Set_Charmap';

(*************************************************************************
 *
 * @function:
 *   FT_Get_Charmap_Index
 *
 * @description:
 *   Retrieve index of a given charmap.
 *
 * @input:
 *   charmap ::
 *     A handle to a charmap.
 *
 * @return:
 *   The index into the array of character maps within the face to which
 *   `charmap' belongs.  If an error occurs, -1 is returned.
 *
 *)
function FT_Get_Charmap_Index(charmap: FT_CharMap): FT_Int; cdecl;
  external LIBFT name _PU + 'FT_Get_Charmap_Index';

(*************************************************************************)
function FT_Get_Char_Index(face: FT_Face; charcode: FT_ULong): FT_UInt; cdecl;
  external LIBFT name _PU + 'FT_Get_Char_Index';

function FT_Get_First_Char(face: FT_Face; agindex: PFT_UInt): FT_ULong; cdecl;
  external LIBFT name _PU + 'FT_Get_First_Char';

function FT_Get_Next_Char(face: FT_Face; char_code: FT_ULong; agindex: PFT_UInt): FT_ULong; cdecl;
  external LIBFT name _PU + 'FT_Get_Next_Char';

(*************************************************************************
 *
 * @function:
 *   FT_Face_Properties
 *
 * @description:
 *   Set or override certain (library or module-wide) properties on a
 *   face-by-face basis.  Useful for finer-grained control and avoiding
 *   locks on shared structures (threads can modify their own faces as
 *   they see fit).
 *
 *   Contrary to @FT_Property_Set, this function uses @FT_Parameter so
 *   that you can pass multiple properties to the target face in one call.
 *   Note that only a subset of the available properties can be
 *   controlled.
 *
 *   * @FT_PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the
 *     property `no-stem-darkening' provided by the `autofit', `cff',
 *     `type1', and `t1cid' modules; see @no-stem-darkening).
 *
 *   * @FT_PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding
 *     to function @FT_Library_SetLcdFilterWeights).
 *
 *   * @FT_PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID
 *     `random' operator, corresponding to the `random-seed' property
 *     provided by the `cff', `type1', and `t1cid' modules; see
 *     @random-seed).
 *
 *   Pass NULL as `data' in @FT_Parameter for a given tag to reset the
 *   option and use the library or module default again.
 *
 * @input:
 *   face ::
 *     A handle to the source face object.
 *
 *   num_properties ::
 *     The number of properties that follow.
 *
 *   properties ::
 *     A handle to an @FT_Parameter array with `num_properties' elements.
 *
 * @return:
 *   FreeType error code.  0~means success.
 *
 * @note:
 *   Here an example that sets three properties.  You must define
 *   FT_CONFIG_OPTION_SUBPIXEL_RENDERING to make the LCD filter examples
 *   work.
 *
 *   {
 *     FT_Parameter         property1;
 *     FT_Bool              darken_stems = 1;
 *
 *     FT_Parameter         property2;
 *     FT_LcdFiveTapFilter  custom_weight =
 *                            { 0x11, 0x44, 0x56, 0x44, 0x11 };
 *
 *     FT_Parameter         property3;
 *     FT_Int32             random_seed = 314159265;
 *
 *     FT_Parameter         properties[3] = { property1,
 *                                            property2,
 *                                            property3 };
 *
 *
 *     property1.tag  = FT_PARAM_TAG_STEM_DARKENING;
 *     property1.data = &darken_stems;
 *
 *     property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
 *     property2.data = custom_weight;
 *
 *     property3.tag  = FT_PARAM_TAG_RANDOM_SEED;
 *     property3.data = &random_seed;
 *
 *     FT_Face_Properties( face, 3, properties );
 *   }
 *
 *   The next example resets a single property to its default value.
 *
 *   {
 *     FT_Parameter  property;
 *
 *
 *     property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
 *     property.data = NULL;
 *
 *     FT_Face_Properties( face, 1, &property );
 *   }
 *
 * @since:
 *   2.8
 *
 *)
function FT_Face_Properties(face: FT_Face; num_properties: FT_UInt; properties: PFT_Parameter): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Face_Properties';

(*************************************************************************)
function FT_Get_Name_Index(face: FT_Face; glyph_name: PFT_String): FT_UInt; cdecl;
  external LIBFT name _PU + 'FT_Get_Name_Index';

(*************************************************************************
 *
 * @func:
 *   FT_Get_SubGlyph_Info
 *
 * @description:
 *   Retrieve a description of a given subglyph.  Only use it if
 *   `glyph->format' is @FT_GLYPH_FORMAT_COMPOSITE; an error is
 *   returned otherwise.
 *
 * @input:
 *   glyph ::
 *     The source glyph slot.
 *
 *   sub_index ::
 *     The index of the subglyph.  Must be less than
 *     `glyph->num_subglyphs'.
 *
 * @output:
 *   p_index ::
 *     The glyph index of the subglyph.
 *
 *   p_flags ::
 *     The subglyph flags, see @FT_SUBGLYPH_FLAG_XXX.
 *
 *   p_arg1 ::
 *     The subglyph's first argument (if any).
 *
 *   p_arg2 ::
 *     The subglyph's second argument (if any).
 *
 *   p_transform ::
 *     The subglyph transformation (if any).
 *
 * @return:
 *   FreeType error code.  0~means success.
 *
 * @note:
 *   The values of `*p_arg1', `*p_arg2', and `*p_transform' must be
 *   interpreted depending on the flags returned in `*p_flags'.  See the
 *   OpenType specification for details.
 *
 *)
function FT_Get_SubGlyph_Info(glyph: FT_GlyphSlot; sub_index: FT_UInt; p_index: PFT_Int; p_flags: PFT_UInt; p_arg1: PFT_Int; p_arg2: PFT_Int; p_transform: PFT_Matrix): FT_Error; cdecl;
  external LIBFT name _PU + 'FT_Get_SubGlyph_Info';

function FT_Get_FSType_Flags(face: FT_Face): FT_UShort; cdecl;
  external LIBFT name _PU + 'FT_Get_FSType_Flags';

(*************************************************************************)
function FT_Face_GetCharVariantIndex(face: FT_Face; charcode: FT_ULong; variantSelector: FT_ULong): FT_UInt; cdecl;
  external LIBFT name _PU + 'FT_Face_GetCharVariantIndex';

(*************************************************************************)
function FT_Face_GetCharVariantIsDefault(face: FT_Face; charcode: FT_ULong; variantSelector: FT_ULong): FT_Int; cdecl;
  external LIBFT name _PU + 'FT_Face_GetCharVariantIsDefault';

function FT_Face_GetVariantSelectors(face: FT_Face): PFT_UInt32; cdecl;
  external LIBFT name _PU + 'FT_Face_GetVariantSelectors';

function FT_Face_GetVariantsOfChar(face: FT_Face; charcode: FT_ULong): PFT_UInt32; cdecl;
  external LIBFT name _PU + 'FT_Face_GetVariantsOfChar';

function FT_Face_GetCharsOfVariant(face: FT_Face; variantSelector: FT_ULong): PFT_UInt32; cdecl;
  external LIBFT name _PU + 'FT_Face_GetCharsOfVariant';

function FT_MulDiv(a: FT_Long; b: FT_Long; c: FT_Long): FT_Long; cdecl;
  external LIBFT name _PU + 'FT_MulDiv';

function FT_MulFix(a: FT_Long; b: FT_Long): FT_Long; cdecl;
  external LIBFT name _PU + 'FT_MulFix';

(*************************************************************************)
function FT_DivFix(a: FT_Long; b: FT_Long): FT_Long; cdecl;
  external LIBFT name _PU + 'FT_DivFix';

(*************************************************************************)
function FT_RoundFix(a: FT_Fixed): FT_Fixed; cdecl;
  external LIBFT name _PU + 'FT_RoundFix';

(*************************************************************************)
function FT_CeilFix(a: FT_Fixed): FT_Fixed; cdecl;
  external LIBFT name _PU + 'FT_CeilFix';

(*************************************************************************)
function FT_FloorFix(a: FT_Fixed): FT_Fixed; cdecl;
  external LIBFT name _PU + 'FT_FloorFix';

(*************************************************************************)
procedure FT_Vector_Transform(vec: PFT_Vector; matrix: PFT_Matrix); cdecl;
  external LIBFT name _PU + 'FT_Vector_Transform';

procedure FT_Library_Version(&library: FT_Library; amajor: PFT_Int; aminor: PFT_Int; apatch: PFT_Int); cdecl;
  external LIBFT name _PU + 'FT_Library_Version';

(*************************************************************************)
function FT_Face_CheckTrueTypePatents(face: FT_Face): FT_Bool; cdecl;
  external LIBFT name _PU + 'FT_Face_CheckTrueTypePatents';

(*************************************************************************)
function FT_Face_SetUnpatentedHinting(face: FT_Face; value: FT_Bool): FT_Bool; cdecl;
  external LIBFT name _PU + 'FT_Face_SetUnpatentedHinting';

implementation

end.